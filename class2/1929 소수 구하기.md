# 1929 소수 구하기

10/17 오늘의 문제는 소수 구하기 이다.

소수 구하기는 **에라토스테네스의 체**라는 걸 알고 있기 때문에 자신감이 있었다.



사담) 10년 정도 집에서 타던 차의 번호판이 1929였다. 그 차는 스타렉스였다. 



```python
# 1929 소수 구하기 

M, N = map(int, input().split())

list = list(range(M, N+1))

for i in range(2, N+1):
    for j in list:
        if (j==i):
            continue
        if (j%i==0):
            list.remove(j)

for i in list:
    print(i)
```

이렇게 짜니까 시간초과다

체를 이용해서 소수를 찾을 땐 자동으로 **이미 제외된 (소수가 아닌) 숫자로는 배수를 검사하지 않**는데 이렇게 짜면 모든 수에 대해 검사한다

따라서 소수 리스트를 만들어 그 안에서만 검사해볼 필요가 있어 보인다.

결국 보니까 1부터 N까지의 모든 소수를 구하고, M보다 큰 것만 출력하는 듯하다 



고쳤는데도 아무튼 알 수 없었음

그래서 걍 검색 ㄱㄱ..

https://deokkk9.tistory.com/17



에라토스테네스가 문제가 아니고, 2부터 i가 아니라 <u>2부터 `i**0.5`까지 검사</u>하는게 핵심인 듯 하다.

제곱근까지면 확실히 시간이 줄어들 것이다 



사실 더 또렷하게 에라토스테네스의 체를 쓰는 방법도 있는데, 그것보단 위에 링크 단 방법이 더 간단하다 (즉, 굳이 체의 형태로 남길 필요가 없다)

true, false에 해당하는 배열을 만들고 출력을 그에 맞게 하는 방법이 매우 유용해 보인다.



```python
# 1929 소수 구하기 

def isPrime(num):
    # output: true, false
    if num == 1: 
        return False
    else:
        for i in range(2, int(num**0.5)+1):
            if num%i == 0:
                return False
            return True

M, N = map(int, input().split())

for i in range(M, N+1):
    if isPrime(i):
        print(i)
```

분명 위 게시물과 똑같이 베.꼇는데

**출력초과**

라고 뜬다.

문제를 풀다 보면 이런 일이 가끔 있는데 그 경우 십중팔구

**어딘가 잘못 베낀** 것이다.

꼭 기억하자.

위의 경우 들여쓰기가 한 칸 잘못된 부분이 있었다.

직접 로직을 짜면 이런 실수는 하지 않겠지만 무지성 복사를 하면 이렇게 된다.



오늘의 교훈

* 거듭제곱 